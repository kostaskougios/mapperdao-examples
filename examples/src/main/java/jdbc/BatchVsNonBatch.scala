package jdbc

import com.googlecode.mapperdao.utils.Setup
import java.util.Properties
import org.apache.commons.dbcp.BasicDataSourceFactory
import com.googlecode.mapperdao.jdbc.Jdbc
import com.googlecode.mapperdao.jdbc.Transaction
import com.googlecode.mapperdao.jdbc.BatchOptions
import com.googlecode.mapperdao.jdbc.Batch
import org.springframework.jdbc.core.SqlParameterValue
import com.googlecode.concurrent.ExecutorServiceManager

/**
 * benchmark of batch vs non-batch jdbc operations
 *
 * @author kostantinos.kougios
 *
 * Nov 19, 2012
 */
object BatchVsNonBatch extends App {
	val BatchSz = 20000
	val MultiThreadedBatch = 2000

	val properties = new Properties
	properties.load(getClass.getResourceAsStream("/tests.properties"))
	val dataSource = BasicDataSourceFactory.createDataSource(properties)
	println("Configuring mapperdao")

	val (j, m, q, txM) = Setup.postGreSql(dataSource, Nil)

	try {
		j.update("drop table BatchVsNonBatch")
	} catch {
		case e => // ignore
	}
	j.update("create table BatchVsNonBatch(id serial primary key, name varchar(50) not null)")

	val tx = Transaction.default(txM)

	def cleanup() = j.update("truncate BatchVsNonBatch")
	def noBatch(times: Int) = tx { () =>
		for (i <- 0 to times) {
			j.updateGetAutoGenerated("insert into BatchVsNonBatch(name) values(?)", "test" + i)
		}
	}

	def batch(times: Int) = tx { () =>
		val args = new Array[Array[SqlParameterValue]](times + 1)
		for (i <- 0 to times) yield {
			args(i) = Array(Jdbc.toSqlParameter(classOf[String], "test" + i))
		}
		j.batchUpdate(BatchOptions(Batch.WithBatch, Array("id")), "insert into BatchVsNonBatch(name) values(?)", args)
	}

	println("initial warmup...")
	noBatch(500)
	batch(500)
	ExecutorServiceManager.lifecycle(40, 1 to 40) { i =>
		noBatch(10)
	}

	{
		cleanup()

		println("warmup...")
		noBatch(1000)

		println("benchmarking non-batch multithreaded insert")
		val start = System.currentTimeMillis
		ExecutorServiceManager.lifecycle(40, 1 to 40) { i =>
			noBatch(MultiThreadedBatch)
		}
		println("no batch multithreaded dt:" + (System.currentTimeMillis - start))
	}

	{
		cleanup()

		println("warmup...")
		batch(1000)

		println("benchmarking batch multithreaded insert")
		val start = System.currentTimeMillis
		ExecutorServiceManager.lifecycle(40, 1 to 40) { i =>
			batch(MultiThreadedBatch)
		}
		println("batch multithreaded dt:" + (System.currentTimeMillis - start))
	}

	{
		cleanup()

		println("warmup...")
		noBatch(1000)

		println("benchmarking non-batch insert")
		val start = System.currentTimeMillis
		noBatch(BatchSz)
		println("no batch dt:" + (System.currentTimeMillis - start))
	}

	{
		cleanup()

		println("warmup...")
		batch(1000)

		println("benchmarking batch insert")
		val start = System.currentTimeMillis
		batch(BatchSz)
		println("batch dt:" + (System.currentTimeMillis - start))
	}
}